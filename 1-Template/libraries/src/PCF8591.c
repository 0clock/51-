/***************************************************************************************************    

维护记录：  2011-8-22
***************************************************************************************************/

#include "PCF8591.h"


//**************************************************************************************************
//启动(SCL为高，SDA由高变为低是一个开始条件)
//**************************************************************************************************
void PCF8591_start()  
{	
	PCF8591_sda=1; _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();   //数据线置高,
	PCF8591_scl=1; _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();   //时钟线置高
	PCF8591_sda=0; _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();   //数据线置低,由高变低
	PCF8591_scl=0; _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();   //时钟线置低,准备发送或接收数据,总线进入忙状态(I2C总线在空闲状态时，SDA与SCL均被置高)
	DelayXus(1);  //延时
}
//**************************************************************************************************
//停止（SCL为高，SDA由低变为高是一个结束条件）
//**************************************************************************************************
void PCF8591_stop()   
{
	PCF8591_sda=0;                   //数据线置低
	DelayXus(1);                 //延时
	PCF8591_scl=1;                   //时钟线置高
	DelayXus(1);                 //延时
	PCF8591_sda=1;                   //数据线置高，由低变高
	DelayXus(1);                 //延时
}
//**************************************************************************************************
//检测应答(所有的地址和数据字都是以8bit,在第9个时钟周期，从器件发出"0"信号来作为收到一个字的应答信号)
//**************************************************************************************************
void PCF8591_checkACK()                   //主器件检测从器件是否返回应答
{
	PCF8591_scl=1;                        //时钟线置高
	DelayXus(1);                      //延时
	while(PCF8591_sda==1);                //等待第9个时钟周期器件发出的响应信号"0"
	PCF8591_scl=0;                        //时钟线置低
	DelayXus(1);                      //延时
}
//**************************************************************************************************
//发送应答(发送方为主器件，接收方为从器件，控制器作为从器件接收完1数据时，发送应答信号
//**************************************************************************************************
void PCF8591_sendACK(bit ACK)                   
{
    if(ACK) PCF8591_sda=1;            //如果i位为1则发送1,即发送"非应答信号"
      else PCF8591_sda=0;            //如果i位为0则发送0,即发送"应答信号"	
    PCF8591_scl=1;                   //时钟线置高,给一个脉冲
	DelayXus(1);                 //延时
	PCF8591_scl=0;                   //时钟线置低
	DelayXus(1);                 //延时
}
//**************************************************************************************************
//写一字节
//**************************************************************************************************
void PCF8591_send_byte(uchar date)       //写一个8位字
{
	uchar i,temp;                //定义局部变量
	temp=date;                   //待发8位数据赋予temp
	for(i=0;i<8;i++)             //循环8次，每次写入1位，从最高位开始发送
	{
        if(temp&0x80) PCF8591_sda=1;      //如果temp最高位为1则发送1
          else   PCF8591_sda=0;            //如果temp最高位为0则发送0
	    _nop_();                 //延时
		PCF8591_scl=1;                   //给一个脉冲，发送sda当前这位数据
		DelayXus(5);                 //延时,需大于4us(参考数据手册时序图) 
                
		PCF8591_scl=0;                   //时钟线置低,准备下一脉冲
	    DelayXus(6);                 //延时,需大于4.7us(参考数据手册时序图) 
  
		temp=temp<<1;            //左移1位，准备好下1位待发送的数据
	}
	PCF8591_checkACK();                  //查询是否返回应答信号
}
//**************************************************************************************************
//读一字节
//**************************************************************************************************
 uchar PCF8591_receive_byte()         //读一个8位字
{
	uchar i,temp;            //定义局部变量
	PCF8591_sda=1;                   //设置数据线为输入
	_nop_();                 //延时
	for(i=0;i<8;i++)         //循环8次，每次读取1位，从最高位开始接收
	{
		PCF8591_scl=1;               //给一脉冲，准备发送1位数据            
		DelayXus(5);             //延时,需大于4us(参考数据手册时序图) 

		temp=(temp<<1)|PCF8591_sda;  //读取1位数据,放在temp最低位
		PCF8591_scl=0;               //准备给下1个脉冲
	    DelayXus(6);             //延时,需大于4.7us(参考数据手册时序图) 
       
	}
    PCF8591_sendACK(0);              //发送应答信号
	return temp;             //返回读取的8位数据
}
//**************************************************************************************************
//读取AD转换结果数据
//**************************************************************************************************
uchar PCF8591_Read_AD(uchar chn)
 {
   uchar  ad_data;          //定义变量，存放转换结果
   PCF8591_stop();                  //停止 
   PCF8591_start();                 //启动总线
   PCF8591_send_byte(0x90);         //选择从器件地址,RW位为0，即选择写命令
   PCF8591_send_byte(0x40|chn);     //寄存器设置，0通道
   
   PCF8591_start();                 //启动I2C总线
   PCF8591_send_byte(0x91);         //选择从器件地址,RW位为1，即选择读命令

   ad_data=PCF8591_receive_byte();  //读取转换结果
   PCF8591_sendACK(1);              //发送非应答信号
   PCF8591_stop();                  //停止 
   return(ad_data);
 }

//**************************************************************************************************
//DA转化函数
//**************************************************************************************************
void PCF8591_DAC(uchar v)
 {
   PCF8591_stop();                  //停止 
   PCF8591_start();                 //启动总线
   PCF8591_send_byte(0x90);         //选择从器件地址,RW位为0，即选择写命令
   PCF8591_send_byte(0x40);         //寄存器设置
   PCF8591_send_byte(v);         //写入数字量
   PCF8591_stop();                  //停止 
 }
