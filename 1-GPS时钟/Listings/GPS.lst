C51 COMPILER V9.60.0.0   GPS                                                               03/10/2022 12:54:20 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE GPS
OBJECT MODULE PLACED IN .\Objects\GPS.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE GPS\GPS.c LARGE RTX51 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\0.96°ÆOLED-SPI;.
                    -\0.96°ÆOLED-SPI\BMP;.\USER;.\delay;.\∞¥º¸;.\BMEBMP280;.\IIC;.\GPS;.\SPI;.\–˝◊™±‡¬Î∆˜;.\1.54'TFT) DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\GPS.lst) TABS(2) OBJECT(.\Objects\GPS.obj)

line level    source

   1          #include "GPS.h"
   2          
   3          char idata gpsRxBuffer[gpsRxBufferLength];
   4          unsigned char RX_Count = 0;
   5          unsigned dayplus=0;
   6          _SaveData Save_Data;
   7          
   8          void Uart_Init()                     
   9          {
  10   1        SCON = 0X50;  //UARTÊñπÂºè1Ôºõ8‰ΩçUART
  11   1        REN  = 1;     //ÂÖÅËÆ∏‰∏≤Ë°åÂè£Êé•Êî∂Êï∞ÊçÆ
  12   1        PCON = 0x00;  //SMOD=0;Ê≥¢ÁâπÁéá‰∏çÂä†ÂÄç
  13   1        TMOD = 0x20;  //T1ÊñπÂºè2ÔºåÁî®‰∫é‰∫ßÁîüÊ≥¢ÁâπÁéá
  14   1        TH1  = 0xFD;  //Ë£ÖÂàùÂÄº
  15   1        TL1  = 0xFD;
  16   1        TR1  = 1;     //ÂêØÂä®ÂÆöÊó∂Âô®1
  17   1        EA   = 1;     //ÊâìÂºÄÂÖ®Â±Ä‰∏≠Êñ≠ÊéßÂà∂
  18   1        ES   = 1;     //ÊâìÂºÄ‰∏≤Ë°åÂè£‰∏≠Êñ≠ 
  19   1        clrStruct();
  20   1      }
  21          
  22          
  23          void RECEIVE_DATA(void) interrupt 4 using 3       
  24          { 
  25   1        unsigned char temp = 0;
  26   1        char i = 0;
  27   1        ES=0;
  28   1        temp = SBUF;
  29   1        RI = 0;
  30   1        if(temp == '$')
  31   1        {
  32   2          RX_Count = 0; 
  33   2        }
  34   1          
  35   1        if(RX_Count <= 5)
  36   1        {
  37   2           gpsRxBuffer[RX_Count++] = temp;
  38   2        }
  39   1        else if(gpsRxBuffer[0] == '$' && gpsRxBuffer[4] == 'M' && gpsRxBuffer[5] == 'C')      //Á°ÆÂÆöÊòØÂê¶Êî∂Âà∞"G
             -PRMC/GNRMC"Ëøô‰∏ÄÂ∏ßÊï∞ÊçÆ
  40   1        {
  41   2          gpsRxBuffer[RX_Count++] = temp;
  42   2          if(temp == '\n')                     
  43   2          {
  44   3            memset(Save_Data.GPS_Buffer, 0, GPS_Buffer_Length);      //Ê∏ÖÁ©∫
  45   3            memcpy(Save_Data.GPS_Buffer, gpsRxBuffer, RX_Count);  //‰øùÂ≠òÊï∞ÊçÆ
  46   3            Save_Data.isGetData = true;
  47   3            RX_Count = 0;
  48   3            memset(gpsRxBuffer, 0, gpsRxBufferLength);      //Ê∏ÖÁ©∫        
  49   3          }
  50   2          
  51   2          if(RX_Count >= 75)
  52   2          {
C51 COMPILER V9.60.0.0   GPS                                                               03/10/2022 12:54:20 PAGE 2   

  53   3            RX_Count = 75;
  54   3            gpsRxBuffer[RX_Count] = '\0';//Ê∑ªÂä†ÁªìÊùüÁ¨¶
  55   3          }     
  56   2        }
  57   1        ES=1; 
  58   1      }
  59          
  60          void clrStruct()
  61          {
  62   1        Save_Data.isGetData = false;
  63   1        Save_Data.isParseData = false;
  64   1        Save_Data.isUsefull = false;
  65   1        memset(Save_Data.GPS_Buffer, 0, GPS_Buffer_Length);      //Ê∏ÖÁ©∫
  66   1        memset(Save_Data.UTCTime, 0, UTCTime_Length);
  67   1        memset(Save_Data.latitude, 0, latitude_Length);
  68   1        memset(Save_Data.N_S, 0, N_S_Length);
  69   1        memset(Save_Data.longitude, 0, longitude_Length);
  70   1        memset(Save_Data.E_W, 0, E_W_Length);
  71   1        
  72   1      }
  73          
  74          void GPS_Handle(void)
  75          {
  76   1        char *subString;
  77   1        char *subStringNext;
  78   1        char i = 0;
  79   1        if (Save_Data.isGetData)
  80   1        {
  81   2          Save_Data.isGetData = false;    
  82   2          for (i = 0 ; i <= 6 ; i++)
  83   2          {
  84   3            if (i == 0)
  85   3            {
  86   4              if ((subString = strstr(Save_Data.GPS_Buffer, ",")) == NULL)
  87   4                  ;
  88   4            }
  89   3            else
  90   3            {
  91   4              subString++;
  92   4              if ((subStringNext = strstr(subString, ",")) != NULL)
  93   4              {
  94   5                char usefullBuffer[2]; 
  95   5                switch(i)
  96   5                {
  97   6                  case 1:memcpy(Save_Data.UTCTime, subString, subStringNext - subString);break; //Ëé∑ÂèñUTCÊó∂Èó¥
  98   6                  case 2:memcpy(usefullBuffer, subString, subStringNext - subString);;break;  //Ëé∑ÂèñUTCÊó∂Èó¥
  99   6                  case 3:memcpy(Save_Data.latitude, subString, subStringNext - subString);break;  //Ëé∑ÂèñÁ∫¨Â∫¶‰ø°ÊÅØ
 100   6                  case 4:memcpy(Save_Data.N_S, subString, subStringNext - subString);break; //Ëé∑ÂèñN/S
 101   6                  case 5:memcpy(Save_Data.longitude, subString, subStringNext - subString);break; //Ëé∑ÂèñÁªèÂ∫¶‰ø°ÊÅØ
 102   6                  case 6:memcpy(Save_Data.E_W, subString, subStringNext - subString);break; //Ëé∑ÂèñE/W
 103   6      
 104   6                  default:break;
 105   6                }
 106   5                subString = subStringNext;
 107   5                Save_Data.isParseData = true;
 108   5                if(usefullBuffer[0] == 'A')
 109   5                  Save_Data.isUsefull = true;
 110   5                else if(usefullBuffer[0] == 'V')
 111   5                  Save_Data.isUsefull = false;
 112   5      
 113   5              }
 114   4            }
C51 COMPILER V9.60.0.0   GPS                                                               03/10/2022 12:54:20 PAGE 3   

 115   3          }
 116   2        }
 117   1      }
 118          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    738    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =    124      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     76    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
