/*********************************************************************************************************
** 文件功能 ：串口通信相关程序
** 工程作者 ：Blue Sky Teams――ZZL
** 工程版本 ：V1.0
*********************************************************************************************************/


#include "usart.h"

uchar data_length=0,flag=0; //声明外部变量
uchar data_buffer[10]={0};  //缓存区

/*********************************************************************************************************
** 函数功能 ：串口初始化
** 函数说明 ：SMOD是电源控制寄存器中PCON的bit7位
**			  T1x12是辅助寄存器AUXR中的bit6位
** 			   实现串口外设的配置，波特率计算方法：SMOD   T1x12 
**	                                               0       0       FSCLK/32/12/(256-TH1)
**                                                 0       1       FSCLK/32/(256-TH1) 
**                                                 1       0       FSCLK*2/32/12(256-TH1)
**                                                 1       1       FSCKL*2/32/(256-TH1)
** 入口参数 ：无
** 出口参数 ：无 
** 详细的介绍请参看STC12C5A60S2.pdf第八章 串行口通信
*********************************************************************************************************/
void USART_Init()
{
	PCON |= 0x80;		//使能波特率倍速位SMOD
	SCON = 0x50;		//8位数据,可变波特率
//	AUXR &= 0xBF;		//定时器1时钟为Fosc/12,即12T
//	AUXR &= 0xFE;		//串口1选择定时器1为波特率发生器
//	TMOD &= 0x0F;		//清除定时器1模式位
	TMOD |= 0x20;		//设定定时器1为8位自动重装方式
	TL1 = 0xFF;		//设定定时初值
	TH1 = 0xFF;		//设定定时器重装值
	ET1 = 0;		//禁止定时器1中断
	TR1 = 1;		//启动定时器1
	EA=1;
	
//	PCON &= 0x7F;		//波特率不倍速 SMOD=0
//	SCON = 0x50;		//设置为方式1,8位数据,可变波特率,接收允许
//	AUXR |= 0x40;		//定时器1时钟为Fosc,即1T
//	TMOD = 0X20;		//定时器1:模式2,8位自动重装模式,用于产生波特率 
//	TL1 = 0XD9;		    //设定定时初值，波特率设置为9600
//	TH1 = 0XD9;		    //设定定时器重装值
//	TR1 = 1;			//启动定时器1
//	ES = 1;				//开串行中断
//	EA = 1;				//开总中断
	//EA、ES置1后，若有串口接收或者发送，则进入执行串口中断服务程序void USART_Interrupt(void)  interrupt 4	 
}	  
/*********************************************************************************************************
** 函数功能 ：发送一个字符
** 入口参数 ：d：待发送的字符
** 出口参数 ：无
*********************************************************************************************************/
void Send_Byte(unsigned char c)
{
	
	SBUF = c;
	while(!TI);	//若发送完成，则TI自动置1，则跳出循环，执行接下来的语句
	TI=0;		// 发送完成,TI必须软件置零，下次发送的时候才硬件才可以将它置一作为判断发送完成的依据
}				 
/*********************************************************************************************************
** 函数功能 ：发送一定长度的字符串
** 入口参数 ：str：待发送字符串的地址
**            length：发送字符串的长度
** 出口参数 ：无
*********************************************************************************************************/
void Send_String(uchar *str ,uint length)	
{
	while(length!=0)
	{
		Send_Byte(*str++) ;
		length --;
	}
}

/*********************************************************************************************************
** 函数功能 ：串口中断服务程序
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************/
void USART_Interrupt(void)  interrupt 4	 
{
	EA = 0; 
   	if(RI) 			//必须判断RI(接收中断标志)是否为1
    {
    	RI=0;
    	data_buffer[data_length++] = SBUF;//将接收到的数据存入到缓冲区内
		if(data_buffer[data_length-1] == '\n' || data_length == 10)flag = 1; //若受到回车键或缓冲区数据接收已满，置位flag
    }
	EA = 1;
}


unsigned char Uart_Receive_Byte()//UART Receive a byteg
{	
	unsigned char dat;
	while(!RI);	 //接收完为1 
	RI = 0;
	dat = SBUF;
	return (dat);
}


/************************** (C) COPYRIGHT 2011 Blue Sky Teams *****END OF FILE*****************************/


//RS485通讯实现

/*
功能描述：	实现485双向通信
硬件连接：  用3位杜邦线分别将J9_0与J17_RO、J9_1与J17_DI以及J9_2与J17_RE连接,
            用1位杜邦线将J11_0与J7_S17连接,用1位杜邦线将J10_0与J13_8连接,
            将甲板和乙板RS485接口的A、B对应（即A对A，B对B）连接。
*/

//sbit    RO     =P3^0;   //定义RO
//sbit    DI     =P3^1;   //定义DI
//sbit    RE     =P3^2;   //定义RE,用于发送接收模式选择
//
//void main(void)
//{
// init_com( ) ;        //初始化串口
// while(1)
// {
//  if(KEY ==0 )        //判断是否有按键按下
//   { 
//    delay(100);       //延时消抖
//    while(KEY ==0);   //等待按键释放
//    RE = 1;           //设置485为发送模式
//    send_char(0xaa);  //发送1字节数据
//   }
//
//  RE=0;               //设置485为接收模式
//  if (read_flag)      //如果取数标志已置位，表示有接收到数据
//    { 
//      read_flag= 0 ;  //取数标志清0 
//      if(ch==0xaa)    //判断485接收到的数据是否正确
//       {LED=0;delay(5000);LED=1;} //如果正确，LED闪烁1下
//    } 
// } 
//}




 
